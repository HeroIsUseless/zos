# ZOS
## 特色功能
zlang的基本单位为zos的基本单位
真正适合程序员的操作系统，原子存储不是文件，而是基本变量，文件夹称为包，包和文件夹还是有区别的
支持未命名变量，这时候自动赋予其数字，就是数组了，一个变量可能会有四种状态，有名有值，有名无值，无名有值，无名无值
所有的程序都是代码(函数)，所有的代码都用解释器执行
有一个存储管理器，存储管理器内，双击基础变量出现预览，双击包进入包里面，双击函数，执行函数而不进去(有执行语句)
这只是存储管理器的特性
其实有命令行的，包和函数，实际上就是open和run
## 总体思路
尽量贴合当前操作系统操作
## 编译原理
多个.z文件的，首先单个文件编译成asm，
然后zl组合成一个文件zos.asm，
然后用nasm编译成zos.bin，
然后混合ipl.bin，boot.bin，制成zos.img
## 执行原理
开机启动后，先进入IPL.asm，boot.asm，跳转到32位系统
进入32位系统后，由于zos.img中，main.asm在最开始，kernel.asm在最后
代码会全部初始化后执行到kernel.asm，然后执行main.asm的once和loop
注：kernel.asm为什么没有被zlang化，可能是因为懒吧。。
## 文件结构
-build/
-doc/
-example/
-log/
-src/
--boot/
---boot.asm
---IPL.asm
--kernel/
---GDT.z
---IDT.z
---kernel.asm
---memory.z
---PDT.z
--lib/
--screen/
--tools/
--main.z
--test.z
## 下一步计划
添加浮点数功能
添加内存

# ZLANG
## 总体思路
跟ZOS高度融合，以ZOS需求为准
以汇编为基本原理，这样会更容易
多吸取数学，语文的概念，如果有冲突，以汇编为准
## 具体实现细节
a: A; [浅拷贝] 
a\init(4,6,8); [执行初始化函数]
a: A(1,2,3); [执行函数并赋予返回值]
函数内返回就是用 .<=1; 或者 func<=1; 也可以返回域，函数什么的
  这个会直接结束当前域的执行，因为主体已经变了，也不太对
# 语法
## 基本语法
按照回车分割语句，如果多条语句在一行，用逗号分割
如果需要多行，则需要在特定的地方断开才行
[不行，比较难做，只能分号了]
```
a<=1;
b<=a;
c<=3, d<=c;
```
## 注释
注释放到中括号里，可以放到代码的任何地方
```
[这是一条注释]
```
或者仅仅有一个左中括号也可以，但无法换行了
```
[这是一条行内注释
```
## 变量
变量有三种基本数据类型，分别是整型，字符串，浮点型，要求变量必须符合zos的基本变量
```
a: 1
a: Int
b: ''
b: String
c: 0.3
c: Float
```
变量必须先声明才能赋值
## 操作符
### 声明运算符
声明运算符为冒号“:”，用来声明变量与函数，变量与函数必须先声明才能赋值或使用
```
a: 1 [变量a声明值为1且为整型]
b: a [变量b声明为a的值和类型]
b <= 3 [变量必须先声明才能赋值]
```
### 赋值运算符
<=或=>或<=>为仅仅赋值，不转换类型，如果类型不同会报错
```
a<=b [把b的值赋给a]
a=>b [把a的值赋给b]
a<=>b [a与b的值相互交换]
```
### 算数运算符
+
-
*
/
### 逻辑运算符
<
>
\<
>/
=
# 是不等于
## 数列
数列用花括号表示，选择其中一个元素用\符号，索引从1开始
```
arr: {1, 2, 3}
b: arr\1
```
## 函数
函数示例如下：
```
add(a, b):(.<=a+b)
c <= add(1, 2)
```
不同于其他语言的return，这里是会一直向下执行的
## 条件语句
条件语句示例如下：
```
if(a>b, (.<=a), (.<=b))            [那这个名字算什么？但名字是不行的，别说有if，还有大写类]
```
## 循环语句
循环语句示例如下：
```
while(a>b, (a<=a-1))
```
## 包
类实际上也是一个函数，当函数返回自己时，即返回了一个类实例
```
cls(a:0, b:0):(c:a+b, .<=cls) [这样感觉都有点辩证了，对，这样也是内存原理的]
d: cls(1,2)
```
类属性可以这样使用
```
cls(a:0, b:0):(
  c:0
  d: .\c
  e: .\a+.\b
  f: a+b
)
```

