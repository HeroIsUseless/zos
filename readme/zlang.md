# ZLANG
## 总体思路
1. 从最基础的设定出发，逐渐拓展，不能突兀地中途设定，每个语法之间都需要相互联系
2. 尽量简约柔和，不能反常识，不能被用户喷

1. 跟ZOS高度融合，以ZOS需求为准
2. 以汇编为基本原理，这样会更容易
3. 多吸取数学，语文的概念，如果有冲突，以汇编为准
4. 同一功能没有两种实现方式，所有人写的基本一样[废弃，概念融合的越多，越可以写出不同的实现方式]
5. 直观性，吸取数学，语文，操作系统，日常生活的概念，尽量没有编程语言自己的概念
6. 防呆性，对于危险操作多写代码以保证安全性，对于简单安全操作少写代码以避免问题的发生
7. 简洁性，对于不必要的不用写代码，对于必要的尽量简洁，没有多余语义，代码越少，编程越舒服
8. 可读性：同时也不能过于简约，以至于丢失了可读性，这是不行的
9. 和谐性，各个语法间能相互解释，对照
10. 优美，没有奇怪的设计

## 已确定
* 基础数据声明
a: 1
b!: 2
c?: 3
* 函数声明
d(): (c?+1)
e(a: 0, b: 0): (a+b)
f(a: 0, b: 0): (c: a+b, d: a-b, c+d)
f(a: 0, b: 0): (
  c: a+b
  d: a-b
  return(c+d)
)
* if与三元表达式统一
if(a, b, c)
* 循环语句
while(a, b)
* 组合数据声明
g: {
  a: 1,
  b: {
    c: 2,
    d: 3,
    .e: 0
  }
}
g.b.d
隐藏变量前加.，这样就能在语法层面直接断掉编译
创建一个类可以将组合数据放到表达式中
createClass(): (
  {
    a: 0,
    b: 1
  }
)
解构：
{ a:0, b:0 } = c
* 数组声明
h: [1, 2, 3]
h[2]
* 运算符
= + - * / ==是等于，#=是不等于，很好理解对不对，把#当作逻辑取反运算符
== 需要类型和值都一样才能比较，但是有一个问题就是取反，在变量前加一个#号
#a!，感觉还可以












1. If与三元表达式统一，循环逻辑同理
if(a, b, (c, a+b, d))，也可以用return提前中断
1. 常量val1，变量val1!，可变类型变量val1?
2. 函数是表达式本身，触发其执行的方式是调用
例如var1: 3，此时会将右侧表达式立即执行，var2: (a+b) 也是如此
如果想表达表达式本身，可以加一个括号，例如 var3(): (a+b, c, d, e:0)，这就是表达式本身，后续如果想执行此表达式，则 var4: var3()
执行是顺序执行，表达式本身是一个组合数据，会从上到下依次执行，已声明的变量会重新声明

只有基本数据和表达式的概念
表达式里面的变量不会创建内存，也不会立即执行，即便是主函数体也是如此的
没有组合数据的概念
而组合数据实际上是一个乱序执行的概念，统一声明，乱序执行
而顺序执行是依次声明，顺序执行
文件本身是一个乱序执行的概念，体现在引用上，是一个结构体
表达式和结构体是完全不同的两种方式
如何定义一个结构体，里面肯定没执行
使用是var/1
通过大括号
大括号的好处是跟其他语言对其
坏处是割裂感很严重
定义一个组合数据：
var1: {
  a: 1,
  b: '',
}
定义一个组合数据模版（在其他语言中，也叫类）：
Var1(a: 0, b: ''): (
  {
    a: a,
    b: b,
  }
)
var1: Var1(1, '')
var1/a（除号怎么办？./.）
访问权限
< public 默认
| protected
> private
例如
var1: {
  < a: 15,
  | b: '',
  > c: 0,
}
解构：
{a, b}: var1
变量名支持小数点有什么意义吗？
当然，支持unicode，但不支持有空格的中间名字
## 开始
Hello world:
```
print("Hello world")
```
代码由语句构成，语句之间用逗号，分号，或者回车分开，如果一条语句需要多行，请在最后一行用分号结束
> 直观性：在语文中也是通过逗号，冒号都可以分割句子，诗歌是通过回车分割句子的
> 和谐性：对于后面的包而言，不用后缀分割能让包更简洁和谐
## 注释
注释放到中括号里，可以放到代码的任何地方，中文的注释倾向于用中括号表示
> ✅ 直观性
```
[这是一条注释]
```
## 字符串
字符串用双引号括起来，里面可以放入单引号''作为模版字符串的变量位置
## 单元（Unit），= 变量+常量+函数+类
单元可以对照其他语言的变量+函数，一个单元是由一个表达式或多个表达式组成，多个表达式时必须用括号括起来
单元有两种类型，变元和常元，单元可以带参
所有单元都需要定义，变元在定义后能赋值，常元不能
变元必须后面跟一个感叹号，常元必须首字母大写
所有的保留字都是首字母小写，没有感叹号的
因为有栈和堆的区分，所以跟普通编程语言一样
定义
```
a: <num>(0)
a: 1
b: num|undefined  [b的值为undefined]
c: "world"
d?: str|undefined|0 [其实跟ts串起来了][如果说弄一个 d: 'a'|'b'|'c'呢，默认最后一个，因此最后一个不能为type]
e: "Hello 'c'" [e的值为"Hello world"]
f: (a+b, c+d) [f的值为"world"][问题在于不会在声明时计算，而是在每次使用时计算，这就变相实现了一种计算属性]
[常量首字母大写，计算量/引用首字母小写，变量后面加感叹号，保留字首字母小写，让你知道，这玩意儿其实是个引用/计算量/函数]
[对于函数而言，必须首字母小写，因为返回值大多都是变动的，如果不是变动的，你可以直接用常量代替]
d(e:2): a+e [d的值为1+e][后面有括号仅仅是带参的问题，因为有参，所以直接调用d不带括号的话就会出错，因此d是一个函数]
e: a+c [e的值为"1world"]
j: {1, 2, 3} [j是一个数组]
h: {i: num, k: 0, m: 'ss'} [h是一个类，也算一种字典]
[因此有没有括号，都会执行，这就是融合的代价，那创建新类，创建数组该怎么办呢？]
[因此简单变量跟函数合为一体，数组/字典和类合为一体]
[怎么加type呢，用注释][一是没地方了，二是本来有类型推断，这样多此一举，放注释最好]
[@return: str][加上@，以防跟普通注释重叠]
o(p: num): p + 'world'
p(q: num): {a: q} [函数，类实际上算定义了一个模版，因为是每次使用时才运行，因此算一个模版]
[函数提前终止用$()]
[但赋值的话是实时计算的]
a: Person('mike')
log(a\name) [第一次使用时才会初始化a，然后调用name]
[如果我想立刻运行呢，不然就太卡了，用语法糖]
a <:= Person('mike') [相当于 a: Person('mike'), a]
[一个枚举]
anim: {cat: 'cat', dog: 'dog'}
```
赋值
[赋值与定义有很大不同，定义是一次定义，定义内容比较宽泛]
[赋值是多次赋值，赋值内容比较受限]
```
a: 1
b: 3
c!: number
c! <= a + b [这时候的c!实际上是a+b的值，而不是a+b这个计算属性]
c!: a + b [这时候的c!实际上是a + b这个引用][跟防呆性有冲突啊]
[类型与实例化合在一起有问题吗]
[会至少占用一块内存][没有用的话也不会编译进去，用一个的话正好，用两个的话拷贝一份就行了]
[稍后初始化，比如说初始化渲染优化]
[也就是模版，num跟class实际上是一类]
[例如一个类，实例化要几百兆，但是整个程序中很少用到，这时候不初始化，就一个undefined，就很好]
a!: num|string
```
## 函数
函数就是语句的集合，用括号括起来，一行语句也是函数，可以不用括号括起来
```
a: (
  b: 1,
  c: (
    e: 2,
    f: 4
  )
  e: 5,
  f!: 6,
  b + e => f,
);
```
句集在调用的时候会被执行，并返回最后一个语句的值，如果你想中断语句的执行，请用$符号，句集将会从$位置中断执行
并返回上一个语句的值
```
func(a:0, b:0): a+b
d: func(1, 2)
```
## 操作符
### 声明运算符
声明运算符为冒号“:”，用来声明变量与函数，变量与函数必须先声明才能赋值或使用
```
a: 1 [变量a声明值为1且为整型]
c: 1, d: 3
b!: a [变量b声明为a的值和类型]
b! <= 3 [变量必须先声明才能赋值]
```
### 赋值运算符
<=或=>或<=>为仅仅赋值，不转换类型，如果类型不同会报错，通过增加赋值困难度，提醒开发者注意其危险性
赋值会引起变量变化，因此赋值是危险的
```
a! <= b [把b的值赋给a]
a => b! [把a的值赋给b]
a! <=> b! [a与b的值相互交换]
```
### 算数运算符
+
-
*
/
可以用<+=实现自加，没有规约冲突的，提供语法糖
<-= <*= </= <<=  <>=
a: 1
b: 2
b <+= a
此时b=3
<.= 代表用该函数透传出去？
\\ 右移动 // 左移 取自路径
### 逻辑运算符
<
>
\<
>/
=
\# 是不等于
## 其他
### 定义/复制与深/浅拷贝
a: A; [浅拷贝] 
a\init(4,6,8); [执行初始化函数]
a: A(1,2,3); [执行函数并赋予返回值]
函数内返回就是用 .<=1; 或者 func<=1; 也可以返回域，函数什么的
  这个会直接结束当前域的执行，因为主体已经变了，也不太对
## 数列
数列用花括号表示（数学上的数列也是如此，并且并没有其他括号用了），
选择其中一个元素用\符号（思路来源于地址，但是容易与/混淆，这个是不好的一点），索引从1开始
```
arr: {1, 2, 3}
b: arr\1
```
## 函数
函数示例如下：
```
add(a, b):(a+b) [定义]
c <= add(1, 2) [使用]
```
不同于其他语言的return，这里是会一直向下执行的，理论上会将最后一句的执行结果作为输出返回
如果你想立即返回，请在语句后使用$(象形，取阻断之意)
add(a, b): (
  a <+= 1
  b <-= 1
  a+b$
  a-b
) [其中，函数从$位置便不再执行，将返回a+b]
## 条件语句
条件语句示例如下：
```
if(a>b, a, b)
if(a>b, (a), (b))            [那这个名字算什么？但名字是不行的，别说有if，还有大写类]
switch(a, )
```
## 循环语句
循环语句示例如下：
```
while(a>b, a<=a-1)
```
## 包
包是计算机存储概念，一个包里面存储变量和其他包
类型体操的话，类型与值统一了
例如定义一个Pack
Pack: (
  a: 1,
  b: number,
  f(c:0, d:0): (c+d),
  [构造函数直接往下写]
  init(): ([malloc之类的，废弃])
);
你可以浅拷贝一个
pack1: Pack;
你可以深拷贝一个
pack2: Pack();
没有函数概念，只有带参变量
也没有变量概念，可以叫单元，分为变元，常元
自由变元，约束变元
你可以带括号，也可以不带括号，但是有参的一定要带括号，因为你要传参
只能返回自己了。。。
cls(a:0, b:0):(c:a+b, cls$) [这样感觉都有点辩证了，对，这样也是内存原理的]
```
d: cls(1,2)
```
类属性可以这样使用
```
cls(a:0, b:0):(
  c:0
  d: .\c
  e: .\a+.\b
  f: a+b
)
```

直观性，防呆性，简洁性，和谐性
反对 突兀性，例如js class 的constroctor以及大多数语言的super函数
Int<: func(x: Int): (

);
感觉还好，这个理论是上面语法推导出来的
如何表示赋值呢？
<= 理由是直观
如何表示定义呢？
: 理由是直观
<: 理由是和谐
可以确定的是，break和return能一统
Int|String<: add(p1: Int|String, p2: Int|String): (
  <.= p1 + p2
)

不同语句同行必须用;，不同行必须不能用;，折行用智能识别
a: (1)
那么a是什么？从数学上来讲，a是1，也就是说，会自动拆包
表达式也是包，执行到包这里就开始进入包执行了
那么函数怎么表示呢？
b: (1+1; 2+2; 3+3;) 此时b=3
add(): (1+1) 那么此时add就代表2，2()这样表示执行，无意义会报错
我为什么要小括号囊括一切呢？
小括号在表达式里会自动解包，在函数/类里代表这个变量
用大括号表示包呢
a: {1} 也会返回1.。。看来不行，还挺统一的
Stage0: <: 这个东西也是在表明你想要返回东西
if或者for好像是个any啊。。。它们是自动推断的
既然运行到包会自动运行并解包，那么怎么定义函数呢？。。。
反歧义性，你不能在变量就是执行，函数就不是执行了，歧义啊，最好都一样
一种模板的感觉，不执行，只赋值
<= 这个其实也是仿呆性，通过加大运动量来表示变量的危险性