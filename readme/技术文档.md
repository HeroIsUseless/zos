## 下一步计划
：添加浮点数功能⚠️
：添加内存⚠️
：：接入GDT和IDT⚠️
## 编译原理
多个.z文件的，首先单个文件编译成asm，
然后zl组合成一个文件zos.asm，
然后用nasm编译成zos.bin，
然后混合ipl.bin，boot.bin，制成zos.img
## 执行原理
开机启动后，先进入IPL.asm，boot.asm，跳转到32位系统
进入32位系统后，由于zos.img中，main.asm在最开始，kernel.asm在最后
代码会全部初始化后执行到kernel.asm，然后执行main.asm的once和loop
注：kernel.asm为什么没有被zlang化，可能是因为懒吧。。
## 总体思路
尽量贴合当前操作系统操作
## 文件结构
-build/
-doc/
-example/
-log/
-src/
--boot/
---boot.asm
---IPL.asm
--kernel/
---GDT.z
---IDT.z
---kernel.asm # 存放一些无法或很难被zlang化的函数，例如内存设置函数
虽然大部分汇编都已经被zlang转译了，但是仍有一些是不可能，也没必要转译的，比如内存设置，
加载GDT等，这些将封装成一个黑盒函数放到kernel.z(想象中的)
---memory.z
---PDT.z
--lib/
--screen/
--tools/
--main.z
--test.z
# zlang
条件循环判断原理：
由于c语言中仅有数组的局限性，打算用cpp中的类实现
目前正在转移中，正在执行成功
就叫am吧，实在是想不到什么好名字了
而且逻辑符合自己心意也是很困难的
大致逻辑是在parse.y里调用asmMapper， // 这里应该是zlang2asm
// 有两个问题，不一定叫zlang，不一定转成asm，我想一行配置改动转成别的asm
// 就叫lang就好了，然后定一个子类，用纯虚函数什么的，就OK了，就不要hpp了
// 因此就不叫langMapper了，因为可以nasmMapper，masmMapper区分
然后不断调用，asmMapper里储存了所有的asm
然后这asm被存到一个文件里
然后这些文件被zlink起来 // 这里的问题是，这里实际连接的是asm，叫asmLink更好
无前缀函数，怎么办，emmmm，因为有类的，有类也就变成了有前缀函数啊，所以是正常的
if的计数，怎么办呢，首先名字叫if，然后看是第几个if就行了，对！
if的实现方法是，ifstart里定义头
第一个表达式算完后执行ifthen，
弹出与0比较，相等就去else
定义一个then的tag
第二个语句算完后执行ifelse
里面就一个jmp end
然后一个tag else
最后有没有else语句，都会执行ifend
里面就一个tag end
总体说一下，就是如此了
目前数组值必须用括号包围
下面是zos的删除，由于新编译器功能的不确定性，因此需要重新构造
循环的i需要向上找，直到找到一个i或者到root也没找到，就需要这样
拆分addChild和down
问题在于if和while，这里默认进入最后一个就行了
会不会没有？不会的，只要你提前addChild就可以了
一个变量有左值和右值，
当一个变量a的地址给变量b的值了，然后呢
变量b的地址是b的地址，变量b的值是a的地址
那么变量b有什么用呢？怎么提取出来a的值呢？
lang也是传值传地址，但理论上说，传进去就应该是它自己才对呀并不需要任何转换才对
但是我做不到，对吧，原数组和传过去的数组地址就是不一样的，除非说，
一开始就按照地址来
不过也正好实现了从1开始啊
那怎么区别数组和普通变量？用的方式不一样
怎么区分字符串和普通变量？把字符串当数组用就行了
普通变量为嘛没有下划线呢？