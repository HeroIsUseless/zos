[全局描述符表GDT（Global Descriptor Table，段表）在整个系统中，全局描述符表GDT只有一张]
[寄存器GDTR用来存放GDT的入口地址]
[分段管理可以把虚拟地址转换成线性地址，而分页管理可以进一步将线性地址转换成物理地址]
[目前分段不起转换作用了，只起权限作用。虚拟地址==线性地址，每个段保存一个页表，用于向物理地址转换]
[GDT存放的是段描述符。GDT一行8字节，一共8192行，实际上只有前1-4行有用]
[Linux内核运行在特权级0，而用户程序运行在特权级别3]
[根据IA32段保护机制规定，特权级3的程序是无法访问特权级为0的段的]
[所以Linux必须为内核用户程序分别创建其代码段和数据段。]
[这就意味着Linux必须创建4个段描述符——特权级0的代码段和数据段，特权级3的代码段和数据段]
[第一个gdt(也就是第0个，注意第0个不能用，必须全是0)]
[第二个gdt是从0x280000开始，长度是0x7ffff，大概就是512KB，用作代码段]
[在执行初始化GDT前，一直在用在boot区的临时GDT]
[现在都是段基址为0，段界限是4GB，没用页表，只能用内存的前4GB]
[GDTR是一个长度为48bit的寄存器，内容为一个32位的基地址和一个16位的段限]
[其中32位的基址是指GDT在内存中的地址，也就是GDTR0地址0x8220，LGDT是装载命令]
[就这样得到基址了，基址是0，加上偏移地址就成逻辑地址了]
[转到32位后，此时的GDT表的地址仍然是物理地址装入GDTR]
[LDT是二级段表，当下快抛弃段表了，LDT不学了]

main.z: @\main.z;
kernel.z: @\kernel.z;

init():(
	[GDT全部清零]
  i: 0;
  while(i<8192, (
    main.z\Addr_GDT\(i*2) <= 0;
    main.z\Addr_GDT\(i*2+1) <= 0;
    i<= i+1;
  ));
	[GDT初始化]
	[第0个数据段全是0]
	[empty]
	[第1个数据段的段地址为0，用作数据段]
	[基地址，共4字节]
	[前面4位是控制位，中间20位是限制，后面8位是控制位，一共32位，4字节]
	kernel.z\setGDT(Addr_GDT+1*8, 0x00000000, 0x0fffff92);
	[第2个数据段的段地址为280000，用作代码段]
	kernel.z\setGDT(Addr_GDT+2*8, 0x00000000, 0x07ffff9a);
	kernel.z\loadGDT();
);
